<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Reverse Engineering Blog</title><link>https://Cy83rTR0n.github.io/website/posts/</link><description>Recent content in Posts on Reverse Engineering Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 18 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://Cy83rTR0n.github.io/website/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Ryuk Malware</title><link>https://Cy83rTR0n.github.io/website/posts/ryuk/</link><pubDate>Sat, 06 Mar 2021 21:29:01 +0800</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/ryuk/</guid><description>Technical Analysis of Ryuk Malware Below details are for stage 1
Name Ryuk Malware 1. MD5 5ac0f050f93f86e69026faea1fbb4450 2. SHA-1 9709774fde9ec740ad6fed8ed79903296ca9d571 3. SHA-256 23f8aa94ffb3c08a62735fe7fee5799880a8f322ce1d55ec49a13a3f85312db2 4. File type Win32 EX Overview It is a 2 stage malware, where the first stage when initiated suddenly vanishes from the system and drops the second stage to carry out the task of privilege escalation, persistence, and process injection. The details about how it carries out each stage are mentioned further in the report.</description></item><item><title>Format String - Write</title><link>https://Cy83rTR0n.github.io/website/posts/arbitary-write/</link><pubDate>Wed, 06 May 2020 21:29:01 +0800</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/arbitary-write/</guid><description>Arbitrary Write ⚖️ Challenge Write-up General Analysis Similar to previous challenge we have format string vulnerability in this challenge also pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x00000000004010c0 putchar@plt 0x00000000004010d0 puts@plt 0x00000000004010e0 fclose@plt 0x00000000004010f0 __stack_chk_fail@plt 0x0000000000401100 printf@plt 0x0000000000401110 fgetc@plt 0x0000000000401120 fopen@plt 0x0000000000401130 __isoc99_scanf@plt 0x0000000000401140 exit@plt 0x0000000000401150 _start 0x0000000000401180 _dl_relocate_static_pie 0x0000000000401190 deregister_tm_clones 0x00000000004011c0 register_tm_clones 0x0000000000401200 __do_global_dtors_aux 0x0000000000401230 frame_dummy 0x0000000000401236 main 0x0000000000401350 __libc_csu_init 0x00000000004013c0 __libc_csu_fini 0x00000000004013c8 _fini pwndbg&amp;gt; So we see that there is only one function of interest to us and that is none other than main.</description></item><item><title>HotPage: The Silent Browser Hijacker</title><link>https://Cy83rTR0n.github.io/website/posts/hotpage/</link><pubDate>Thu, 18 Jul 2024 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/hotpage/</guid><description>Overiew Recently there has been a new adware which goes by the name as &amp;ldquo;HotPage&amp;rdquo;. It comes in the disguise of giving protection from random advertisements and malicious websites, however in the background it drops a malicious signed driver which gives the attacker privileges to execute arbitary code on Windows hosts.
Infection Chain Though the actual process by which the installer is shared is still unknown, however. The installer places the driver on the disk and initiates a service to execute it.</description></item><item><title>Malware Analysis Article</title><link>https://Cy83rTR0n.github.io/website/posts/latredocus/</link><pubDate>Thu, 18 Jul 2024 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/latredocus/</guid><description>Latredocus Exposed: Unraveling the New Cyber Threat Overview In this report, we delve into the intricate details of Latrodectus, a new and sophisticated malware loader that has surfaced in the cybersecurity landscape. First identified in phishing campaigns in early March 2024, Latrodectus is believed to be the successor to the notorious IcedID malware. This report aims to provide a comprehensive analysis of Latrodectus, including its infection chain, capabilities, and the broader implications for cybersecurity.</description></item><item><title>Fuzzing - 1</title><link>https://Cy83rTR0n.github.io/website/posts/fuzzing-basics/</link><pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/fuzzing-basics/</guid><description>Fuzzers and Fuzzing Introduction Fuzzing is a software testing method that involves sending random or unexpected input to a program to uncover vulnerabilites and bugs. The process includes generating diverse inputs, injecting them into the target software, and observing how it reacts. If the program crashes or exhibits unexpected behavior, it signals potential issues. Fuzzing is valuable for finding security vulnerabilities, and it comes in various types like random, mutation-based and generation-based fuzzing.</description></item><item><title>Process Hollowing Demistyfied</title><link>https://Cy83rTR0n.github.io/website/posts/process-hollowing/</link><pubDate>Tue, 25 Apr 2023 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/process-hollowing/</guid><description>About Process hollowing is a technique used by several malware authors used to run a legitimate process in suspended state and then replacing it&amp;rsquo;s code with the contents of a new process.
Positive implications Before Understanding about how it is actually used in malware development, let&amp;rsquo;s look at how can it be used for helping software developers during SDLC.
a) It can be used for identifying vulnerabilities in software before deployment.</description></item><item><title>Format String - Read</title><link>https://Cy83rTR0n.github.io/website/posts/arbitary-read/</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/arbitary-read/</guid><description>Arbitrary Read ⚖️ Challenge Write-up General Analysis Checking for Format String Vulnerability Starting Exploit to find the address leak #!/usr/bin/python3 from pwn import * context.log_level = &amp;#39;error&amp;#39; for i in range(1,50): io = process(&amp;#39;./fmt_read&amp;#39;) payload = f&amp;#39;%{i}$p&amp;#39; io.sendline(payload) print(io.recvall()) io.close() using the above we will be able to get address leaks from stack
Pulling out the password from the leak Enter Password - Pa$$w0rd_1s_0n_Th3_St4ck What you are looking for is here - 0x404080 Enter String - %p.</description></item><item><title>Return Oriented Programming Series - 1</title><link>https://Cy83rTR0n.github.io/website/posts/rop/</link><pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/rop/</guid><description>Return Oriented Programming ⚖️ Challenge Write-up General Analysis Functions pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x00000000004010a0 setresuid@plt 0x00000000004010b0 setresgid@plt 0x00000000004010c0 system@plt 0x00000000004010d0 printf@plt 0x00000000004010e0 geteuid@plt 0x00000000004010f0 gets@plt 0x0000000000401100 getegid@plt 0x0000000000401110 _start 0x0000000000401140 _dl_relocate_static_pie 0x0000000000401150 deregister_tm_clones 0x0000000000401180 register_tm_clones 0x00000000004011c0 __do_global_dtors_aux 0x00000000004011f0 frame_dummy 0x00000000004011f6 callme 0x0000000000401222 init 0x000000000040126f main 0x00000000004012b0 __libc_csu_init 0x0000000000401320 __libc_csu_fini 0x0000000000401328 _fini pwndbg&amp;gt; pwndbg&amp;gt; disass main Dump of assembler code for function main: 0x000000000040126f &amp;lt;+0&amp;gt;: endbr64 0x0000000000401273 &amp;lt;+4&amp;gt;: push rbp 0x0000000000401274 &amp;lt;+5&amp;gt;: mov rbp,rsp 0x0000000000401277 &amp;lt;+8&amp;gt;: sub rsp,0x20 0x000000000040127b &amp;lt;+12&amp;gt;: mov eax,0x0 0x0000000000401280 &amp;lt;+17&amp;gt;: call 0x401222 &amp;lt;init&amp;gt; 0x0000000000401285 &amp;lt;+22&amp;gt;: lea rdi,[rip+0xd78] # 0x402004 0x000000000040128c &amp;lt;+29&amp;gt;: mov eax,0x0 0x0000000000401291 &amp;lt;+34&amp;gt;: call 0x4010d0 &amp;lt;printf@plt&amp;gt; 0x0000000000401296 &amp;lt;+39&amp;gt;: lea rax,[rbp-0x20] 0x000000000040129a &amp;lt;+43&amp;gt;: mov rdi,rax 0x000000000040129d &amp;lt;+46&amp;gt;: mov eax,0x0 0x00000000004012a2 &amp;lt;+51&amp;gt;: call 0x4010f0 &amp;lt;gets@plt&amp;gt; 0x00000000004012a7 &amp;lt;+56&amp;gt;: mov eax,0x0 0x00000000004012ac &amp;lt;+61&amp;gt;: leave 0x00000000004012ad &amp;lt;+62&amp;gt;: ret End of assembler dump.</description></item><item><title>Overflow - 2</title><link>https://Cy83rTR0n.github.io/website/posts/ret2shellcode/</link><pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/ret2shellcode/</guid><description>Buffer Overflow (ret2shellcode) ⚖️ Challenge Write-up General Analysis Functions pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x00000000004010b0 puts@plt 0x00000000004010c0 setresuid@plt 0x00000000004010d0 setresgid@plt 0x00000000004010e0 printf@plt 0x00000000004010f0 geteuid@plt 0x0000000000401100 gets@plt 0x0000000000401110 getegid@plt 0x0000000000401120 execl@plt 0x0000000000401130 _start 0x0000000000401160 _dl_relocate_static_pie 0x0000000000401170 deregister_tm_clones 0x00000000004011a0 register_tm_clones 0x00000000004011e0 __do_global_dtors_aux 0x0000000000401210 frame_dummy 0x0000000000401216 win 0x0000000000401259 init 0x00000000004012a6 main 0x0000000000401310 __libc_csu_init 0x0000000000401380 __libc_csu_fini 0x0000000000401388 _fini pwndbg&amp;gt; no win function to call shellcode, need to inject our very own into the system.</description></item><item><title>Overflow - 1</title><link>https://Cy83rTR0n.github.io/website/posts/ret2win/</link><pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/ret2win/</guid><description>Buffer Overflow (ret2win) ⚖️ Challenge Write-up General Analysis Function Analysis pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x00000000004010b0 puts@plt 0x00000000004010c0 setresuid@plt 0x00000000004010d0 setresgid@plt 0x00000000004010e0 printf@plt 0x00000000004010f0 geteuid@plt 0x0000000000401100 gets@plt 0x0000000000401110 getegid@plt 0x0000000000401120 execl@plt 0x0000000000401130 _start 0x0000000000401160 _dl_relocate_static_pie 0x0000000000401170 deregister_tm_clones 0x00000000004011a0 register_tm_clones 0x00000000004011e0 __do_global_dtors_aux 0x0000000000401210 frame_dummy 0x0000000000401216 win 0x0000000000401259 init 0x00000000004012a6 main 0x0000000000401310 __libc_csu_init 0x0000000000401380 __libc_csu_fini 0x0000000000401388 _fini pwndbg&amp;gt; Disassembly of win pwndbg&amp;gt; disass win Dump of assembler code for function win: 0x0000000000401216 &amp;lt;+0&amp;gt;: endbr64 0x000000000040121a &amp;lt;+4&amp;gt;: push rbp 0x000000000040121b &amp;lt;+5&amp;gt;: mov rbp,rsp 0x000000000040121e &amp;lt;+8&amp;gt;: lea rdi,[rip+0xddf] # 0x402004 0x0000000000401225 &amp;lt;+15&amp;gt;: call 0x4010b0 &amp;lt;puts@plt&amp;gt; 0x000000000040122a &amp;lt;+20&amp;gt;: mov r8d,0x0 0x0000000000401230 &amp;lt;+26&amp;gt;: lea rcx,[rip+0xde5] # 0x40201c 0x0000000000401237 &amp;lt;+33&amp;gt;: lea rdx,[rip+0xde6] # 0x402024 0x000000000040123e &amp;lt;+40&amp;gt;: lea rsi,[rip+0xde2] # 0x402027 0x0000000000401245 &amp;lt;+47&amp;gt;: lea rdi,[rip+0xdd0] # 0x40201c 0x000000000040124c &amp;lt;+54&amp;gt;: mov eax,0x0 0x0000000000401251 &amp;lt;+59&amp;gt;: call 0x401120 &amp;lt;execl@plt&amp;gt; 0x0000000000401256 &amp;lt;+64&amp;gt;: nop 0x0000000000401257 &amp;lt;+65&amp;gt;: pop rbp 0x0000000000401258 &amp;lt;+66&amp;gt;: ret End of assembler dump.</description></item><item><title>Format String - GOT Overwrite</title><link>https://Cy83rTR0n.github.io/website/posts/got-overwrite/</link><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/got-overwrite/</guid><description>GOT Overwrite Attack ⚖️ Challenge Write-up General Analysis Functions Analysis pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x0000000000401080 puts@plt 0x0000000000401090 printf@plt 0x00000000004010a0 __isoc99_scanf@plt 0x00000000004010b0 exit@plt 0x00000000004010c0 execl@plt 0x00000000004010d0 _start 0x0000000000401100 _dl_relocate_static_pie 0x0000000000401110 deregister_tm_clones 0x0000000000401140 register_tm_clones 0x0000000000401180 __do_global_dtors_aux 0x00000000004011b0 frame_dummy 0x00000000004011b6 win 0x00000000004011f9 main 0x0000000000401260 __libc_csu_init 0x00000000004012d0 __libc_csu_fini 0x00000000004012d8 _fini pwndbg&amp;gt; Exploit to find where is our input going #!/usr/bin/python3 from pwn import * context.log_level = &amp;#39;error&amp;#39; for i in range(1,50): io = process(&amp;#39;.</description></item><item><title>Return to Libc</title><link>https://Cy83rTR0n.github.io/website/posts/ret2libc/</link><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/ret2libc/</guid><description>Return to Libc ⚖️ Challenge Write-up General Analysis Functions pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000401000 _init 0x0000000000401090 setresuid@plt 0x00000000004010a0 setresgid@plt 0x00000000004010b0 printf@plt 0x00000000004010c0 geteuid@plt 0x00000000004010d0 gets@plt 0x00000000004010e0 getegid@plt 0x00000000004010f0 _start 0x0000000000401120 _dl_relocate_static_pie 0x0000000000401130 deregister_tm_clones 0x0000000000401160 register_tm_clones 0x00000000004011a0 __do_global_dtors_aux 0x00000000004011d0 frame_dummy 0x00000000004011d6 init 0x0000000000401223 main 0x0000000000401270 __libc_csu_init 0x00000000004012e0 __libc_csu_fini 0x00000000004012e8 _fini pwndbg&amp;gt; pwndbg&amp;gt; disass main Dump of assembler code for function main: 0x0000000000401223 &amp;lt;+0&amp;gt;: endbr64 0x0000000000401227 &amp;lt;+4&amp;gt;: push rbp 0x0000000000401228 &amp;lt;+5&amp;gt;: mov rbp,rsp 0x000000000040122b &amp;lt;+8&amp;gt;: sub rsp,0x20 0x000000000040122f &amp;lt;+12&amp;gt;: mov eax,0x0 0x0000000000401234 &amp;lt;+17&amp;gt;: call 0x4011d6 &amp;lt;init&amp;gt; 0x0000000000401239 &amp;lt;+22&amp;gt;: lea rdi,[rip+0xdc4] # 0x402004 0x0000000000401240 &amp;lt;+29&amp;gt;: mov eax,0x0 0x0000000000401245 &amp;lt;+34&amp;gt;: call 0x4010b0 &amp;lt;printf@plt&amp;gt; 0x000000000040124a &amp;lt;+39&amp;gt;: lea rax,[rbp-0x20] 0x000000000040124e &amp;lt;+43&amp;gt;: mov rdi,rax 0x0000000000401251 &amp;lt;+46&amp;gt;: mov eax,0x0 0x0000000000401256 &amp;lt;+51&amp;gt;: call 0x4010d0 &amp;lt;gets@plt&amp;gt; 0x000000000040125b &amp;lt;+56&amp;gt;: mov eax,0x0 0x0000000000401260 &amp;lt;+61&amp;gt;: leave 0x0000000000401261 &amp;lt;+62&amp;gt;: ret End of assembler dump.</description></item><item><title>WhisperGate Malware</title><link>https://Cy83rTR0n.github.io/website/posts/whispergate/</link><pubDate>Tue, 01 Nov 2022 17:55:28 +0800</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/whispergate/</guid><description>Understanding the working of a Wiper Malware About Microsoft published a report describing a malware campaign given the name “WhisperGate” that is targeting Ukrainian systems including government agencies and technology organizations. This malware takes destructive actions on the host in order to render the victim inoperable under the guise of a ransomware infection.
What is a Data Wiper Malware? The term &amp;ldquo;Wiper&amp;rdquo; derives its name from its fundamental purpose, which is to wipe out data and files with malicious intent.</description></item><item><title>Trojan Horse</title><link>https://Cy83rTR0n.github.io/website/posts/trojan-horse/</link><pubDate>Thu, 15 Apr 2021 23:39:49 +0530</pubDate><guid>https://Cy83rTR0n.github.io/website/posts/trojan-horse/</guid><description>Understanding the working of Trojans What is a Trojan? A Trojan is a type of malicious software that masquerades as legitimate software but carries out harmful actions on a computer or device. It tricks users into installing it, enabling theft of data, unauthorised access, and other security breaches. Trojans can be spread through various means, such as email attachments, software downloads, and even through websites. Once installed, they can remain undetected while stealing sensitive information such as passwords, credit card numbers, and banking information.</description></item></channel></rss>